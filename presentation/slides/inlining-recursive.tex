\begin{frame}[fragile]{Function inlining: recursion}

  \begin{block}{}
    Replace a function \textbf{call site} with the \textbf{body} of the called function.
  \end{block}

\begin{scalacode}
inline def factorial(n: Int): Int =
  if n == 0 then 1
  else n * factorial(n - 1)
\end{scalacode}

  \vfill

\begin{scalacode}
val f = factorial(3)
\end{scalacode}

  \pause

  \compilesto

\begin{scalacode}
// 3 * (2 * (1 * (1))
val f = 6
\end{scalacode}

(the compiler also performs a \textbf{constant folding} optimization)

  \note<1>{
    \begin{itemize}
        \item Inlining also works with recursive functions
        \item Here is a classic example with the factorial function
    \end{itemize}
  }

  \note<2>{
    \begin{itemize}
        \item Again, thanks to constant folding we ultimately this code compiles to a literal, essentially "computing" the result at compilation-time
        \item In fact, inlining alone is Turing-complete. This comes to no surprise as lambda calculus is itself Turing-complete
    \end{itemize}
  }

\end{frame}
